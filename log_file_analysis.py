# -*- coding: utf-8 -*-
"""LOG_FILE_ANALYSIS.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1OnqQtHuz85szAkwtXfJU81bKg6cEaqzc
"""

import re
from datetime import datetime
from collections import defaultdict

# This is my log analyzer
def analyze_log_file(log_file_path):
    # colors make it look AWESOME!!!
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    BOLD = "\033[1m"
    END = "\033[0m"

    # regex for logs
    pattern = r'(\d+\.\d+\.\d+\.\d+) - - \[(\d+/\w+/\d+:\d+:\d+:\d+) [+\-]\d+\] "GET (/\S*) HTTP/\d\.\d" (\d+)'

    # track
    failed_login_dict = defaultdict(list)

    # these are the DANGER URLS
    BAD_URLS = ['/admin', '/wp-admin', '/phpmyadmin', '/secret', '/dashboard']

    # keep track of
    requests = []
    status_dict = defaultdict(int)
    ips = set()

    # important security events
    brute_list = []
    forbidden_list = []  # 403
    scan_list = []  # 404
    access_list = []  # 200

    # first lets open the file!
    try:
        f = open(log_file_path, 'r')

        # loop through everything
        for l in f:
            m = re.search(pattern, l)
            if m:
                ip = m.group(1)
                time = m.group(2)
                url = m.group(3)
                code = m.group(4)

                # save EVERYTHING!!
                requests.append((ip, time, url, code))

                # count all status codes
                status_dict[code] = status_dict[code] + 1

                # add IP to unique list
                ips.add(ip)

                # check for BAD LOGINS
                if url == '/login' and code == '401':
                    # parse the time
                    t = datetime.strptime(time, '%d/%b/%Y:%H:%M:%S')

                    # evidence
                    failed_login_dict[ip].append(t)

                # check for BAD URLs
                is_bad_url = False
                for bad in BAD_URLS:
                    if url.startswith(bad):
                        is_bad_url = True
                        break

                if is_bad_url:
                    if code == '403':
                        forbidden_list.append((ip, url, time))
                    elif code == '404':
                        scan_list.append((ip, url, time))
                    elif code == '200':
                        access_list.append((ip, url, time))

        f.close()

        # find the BRUTE FORCE ATTACKERS
        for hacker_ip, times_tried in failed_login_dict.items():
            # put timestamps in order
            times_tried.sort()

            # how many times
            tries = len(times_tried)

            # check for brute force - more than 3 tries in 5 mins = HACKER
            is_hacker = False
            if tries > 3:
                for i in range(len(times_tried) - 3):
                    minutes_diff = (times_tried[i+3] - times_tried[i]).total_seconds() / 60
                    if minutes_diff <= 5:
                        is_hacker = True
                        break

            # store all login fails
            if tries > 0:
                brute_list.append((hacker_ip, tries, is_hacker))

        # PRINT THE RESULTS
        print(f"\n{BOLD}{BLUE}SECURITY REPORT{END}\n")


        #Brute force stuff
        print(f"{BLUE}{BOLD}SUSPECTED LOGIN HACK ATTEMPTS{END}")
        print(f"{BLUE}*****************************{END}")
        if len(brute_list) > 0:
            # most dangerous hackers first!!
            brute_list.sort(key=lambda x: x[1], reverse=True)
            for ip, tries, is_hacker in brute_list:
                warning = f"{YELLOW}POSSIBLE BRUTE FORCE ATTACK{END}" if is_hacker else ""
                print(f"{ip} - {tries} failed login attempts{warning}")
        else:
            print("No failed logins found.")

        #Blocked attempts
        print(f"\n{RED}{BOLD}BLOCKED SUSPECTED BAD ACTORS (403){END}")
        print(f"{RED}**********************************{END}")
        if len(forbidden_list) > 0:
            # group by IP
            ip_to_attempts = defaultdict(list)
            for ip, url, time in forbidden_list:
                ip_to_attempts[ip].append((url, time))

            # print each concerning IP
            ip_list = list(ip_to_attempts.keys())
            ip_list.sort()
            for ip in ip_list:
                attempts = ip_to_attempts[ip]
                print(f"{ip} tried {len(attempts)} blocked attempts:")
                for url, time in attempts:
                    print(f"  -> {url} at {time}")
        else:
            print("No blocked attempts found.")

        # 3. Scanners looking for vulnerable stuff
        print(f"\n{BLUE}{BOLD}VULNERABILITY SCANNERS (404){END}")
        print(f"{BLUE}****************************{END}")
        if len(scan_list) > 0:
            # group by ip again
            ip_to_scans = defaultdict(list)
            for ip, url, time in scan_list:
                ip_to_scans[ip].append((url, time))

            # print the scanners!!
            ip_list = list(ip_to_scans.keys())
            ip_list.sort()
            for ip in ip_list:
                scans = ip_to_scans[ip]
                print(f"{ip} did {len(scans)} scan attempts:")
                for url, time in scans:
                    print(f"  -> {url} at {time}")
        else:
            print("No scanning detected.")

        # 4. Breach
        print(f"\n{RED}{BOLD}SUCCESSFUL ACCESS TO RESTRICTED AREAS (200 OK){END}")
        print(f"{RED}**********************************************{END}")
        if len(access_list) > 0:
            # group IPs of successful access to restricted spaces
            ip_to_access = defaultdict(list)
            for ip, url, time in access_list:
                ip_to_access[ip].append((url, time))

            # print breach
            ip_list = list(ip_to_access.keys())
            ip_list.sort()
            for ip in ip_list:
                access = ip_to_access[ip]
                print(f"{RED}{ip} got access {len(access)} times!!:{END}")
                for url, time in access:
                    print(f"{RED}  -> {url} at {time}{END}")
        else:
            print("NO UNAUTHORIZED ACCESS")

        # 5. summary
        print(f"\n{GREEN}{BOLD}LOG SUMMARY{END}")
        print(f"{GREEN}***********{END}")
        print(f"Total Requests: {len(requests)}")
        print(f"Unique IPs: {len(ips)}")
        print("Status Codes:")

        # what the codes mean
        code_names = {
            '200': 'OK',
            '401': 'Unauthorized',
            '403': 'Forbidden',
            '404': 'Not Found'
        }

        # print all the codes
        codes = list(status_dict.keys())
        codes.sort()
        for code in codes:
            if code in code_names:
                print(f"  - {code} {code_names[code]}: {status_dict[code]}")
            else:
                print(f"  - {code}: {status_dict[code]}")

    except FileNotFoundError:
        print(f"ERROR! Cannot find file {log_file_path}!!!")
    except Exception as e:
        print(f"SOMETHING BROKE!!! Error: {str(e)}")

# Run code
# Change log file to specific file path
if __name__ == "__main__":
    log_path = "/content/access_ log_ file.txt"
    analyze_log_file(log_path)

#Code now includes a sample data pack string so the code will work without fetching an exterior file

import re
from datetime import datetime
from collections import defaultdict
from io import StringIO

# Sample log data embedded in the code
SAMPLE_LOG_DATA = """192.168.1.100 - - [10/Oct/2023:13:55:36 +0000] "GET /index.html HTTP/1.1" 200
192.168.1.101 - - [10/Oct/2023:13:56:15 +0000] "GET /login HTTP/1.1" 401
192.168.1.101 - - [10/Oct/2023:13:56:30 +0000] "GET /login HTTP/1.1" 401
192.168.1.101 - - [10/Oct/2023:13:56:45 +0000] "GET /login HTTP/1.1" 401
192.168.1.101 - - [10/Oct/2023:13:57:00 +0000] "GET /login HTTP/1.1" 401
192.168.1.102 - - [10/Oct/2023:14:10:20 +0000] "GET /admin HTTP/1.1" 403
192.168.1.102 - - [10/Oct/2023:14:10:35 +0000] "GET /wp-admin HTTP/1.1" 403
192.168.1.103 - - [10/Oct/2023:14:15:10 +0000] "GET /phpmyadmin HTTP/1.1" 404
192.168.1.103 - - [10/Oct/2023:14:15:25 +0000] "GET /secret HTTP/1.1" 404
192.168.1.104 - - [10/Oct/2023:14:20:45 +0000] "GET /dashboard HTTP/1.1" 200
192.168.1.105 - - [10/Oct/2023:14:25:30 +0000] "GET /login HTTP/1.1" 401
192.168.1.100 - - [10/Oct/2023:14:30:15 +0000] "GET /home.html HTTP/1.1" 200
192.168.1.106 - - [10/Oct/2023:14:35:20 +0000] "GET /admin HTTP/1.1" 200
192.168.1.107 - - [10/Oct/2023:14:40:10 +0000] "GET /wp-admin/users.php HTTP/1.1" 404
192.168.1.108 - - [10/Oct/2023:14:45:25 +0000] "GET /secret/config.php HTTP/1.1" 200"""

# This is my log analyzer
def analyze_log_data(log_data):
    # colors make it look AWESOME!!!
    RED = "\033[91m"
    GREEN = "\033[92m"
    YELLOW = "\033[93m"
    BLUE = "\033[94m"
    BOLD = "\033[1m"
    END = "\033[0m"

    # regex for logs
    pattern = r'(\d+\.\d+\.\d+\.\d+) - - \[(\d+/\w+/\d+:\d+:\d+:\d+) [+\-]\d+\] "GET (/\S*) HTTP/\d\.\d" (\d+)'

    # track
    failed_login_dict = defaultdict(list)

    # these are the DANGER URLS
    BAD_URLS = ['/admin', '/wp-admin', '/phpmyadmin', '/secret', '/dashboard']

    # keep track of
    requests = []
    status_dict = defaultdict(int)
    ips = set()

    # important security events
    brute_list = []
    forbidden_list = []  # 403
    scan_list = []  # 404
    access_list = []  # 200

    try:
        # Create a StringIO object from our sample data
        log_lines = log_data.strip().split('\n')

        # loop through everything
        for l in log_lines:
            m = re.search(pattern, l)
            if m:
                ip = m.group(1)
                time = m.group(2)
                url = m.group(3)
                code = m.group(4)

                # save EVERYTHING!!
                requests.append((ip, time, url, code))

                # count all status codes
                status_dict[code] = status_dict[code] + 1

                # add IP to unique list
                ips.add(ip)

                # check for BAD LOGINS
                if url == '/login' and code == '401':
                    # parse the time
                    t = datetime.strptime(time, '%d/%b/%Y:%H:%M:%S')

                    # evidence
                    failed_login_dict[ip].append(t)

                # check for BAD URLs
                is_bad_url = False
                for bad in BAD_URLS:
                    if url.startswith(bad):
                        is_bad_url = True
                        break

                if is_bad_url:
                    if code == '403':
                        forbidden_list.append((ip, url, time))
                    elif code == '404':
                        scan_list.append((ip, url, time))
                    elif code == '200':
                        access_list.append((ip, url, time))

        # find the BRUTE FORCE ATTACKERS
        for hacker_ip, times_tried in failed_login_dict.items():
            # put timestamps in order
            times_tried.sort()

            # how many times
            tries = len(times_tried)

            # check for brute force - more than 3 tries in 5 mins = HACKER
            is_hacker = False
            if tries > 3:
                for i in range(len(times_tried) - 3):
                    minutes_diff = (times_tried[i+3] - times_tried[i]).total_seconds() / 60
                    if minutes_diff <= 5:
                        is_hacker = True
                        break

            # store all login fails
            if tries > 0:
                brute_list.append((hacker_ip, tries, is_hacker))

        # PRINT THE RESULTS
        print(f"\n{BOLD}{BLUE}SECURITY REPORT{END}\n")

        #Brute force stuff
        print(f"{BLUE}{BOLD}SUSPECTED LOGIN HACK ATTEMPTS{END}")
        print(f"{BLUE}*****************************{END}")
        if len(brute_list) > 0:
            # most dangerous hackers first!!
            brute_list.sort(key=lambda x: x[1], reverse=True)
            for ip, tries, is_hacker in brute_list:
                warning = f" {YELLOW}POSSIBLE BRUTE FORCE ATTACK{END}" if is_hacker else ""
                print(f"{ip} - {tries} failed login attempts{warning}")
        else:
            print("No failed logins found.")

        #Blocked attempts
        print(f"\n{RED}{BOLD}BLOCKED SUSPECTED BAD ACTORS (403){END}")
        print(f"{RED}**********************************{END}")
        if len(forbidden_list) > 0:
            # group by IP
            ip_to_attempts = defaultdict(list)
            for ip, url, time in forbidden_list:
                ip_to_attempts[ip].append((url, time))

            # print each concerning IP
            ip_list = list(ip_to_attempts.keys())
            ip_list.sort()
            for ip in ip_list:
                attempts = ip_to_attempts[ip]
                print(f"{ip} tried {len(attempts)} blocked attempts:")
                for url, time in attempts:
                    print(f"  -> {url} at {time}")
        else:
            print("No blocked attempts found.")

        # 3. Scanners looking for vulnerable stuff
        print(f"\n{BLUE}{BOLD}VULNERABILITY SCANNERS (404){END}")
        print(f"{BLUE}****************************{END}")
        if len(scan_list) > 0:
            # group by ip again
            ip_to_scans = defaultdict(list)
            for ip, url, time in scan_list:
                ip_to_scans[ip].append((url, time))

            # print the scanners!!
            ip_list = list(ip_to_scans.keys())
            ip_list.sort()
            for ip in ip_list:
                scans = ip_to_scans[ip]
                print(f"{ip} did {len(scans)} scan attempts:")
                for url, time in scans:
                    print(f"  -> {url} at {time}")
        else:
            print("No scanning detected.")

        # 4. Breach
        print(f"\n{RED}{BOLD}SUCCESSFUL ACCESS TO RESTRICTED AREAS (200 OK){END}")
        print(f"{RED}**********************************************{END}")
        if len(access_list) > 0:
            # group IPs of successful access to restricted spaces
            ip_to_access = defaultdict(list)
            for ip, url, time in access_list:
                ip_to_access[ip].append((url, time))

            # print breach
            ip_list = list(ip_to_access.keys())
            ip_list.sort()
            for ip in ip_list:
                access = ip_to_access[ip]
                print(f"{RED}{ip} got access {len(access)} times!!:{END}")
                for url, time in access:
                    print(f"{RED}  -> {url} at {time}{END}")
        else:
            print("NO UNAUTHORIZED ACCESS")

        # 5. summary
        print(f"\n{GREEN}{BOLD}LOG SUMMARY{END}")
        print(f"{GREEN}***********{END}")
        print(f"Total Requests: {len(requests)}")
        print(f"Unique IPs: {len(ips)}")
        print("Status Codes:")

        # what the codes mean
        code_names = {
            '200': 'OK',
            '401': 'Unauthorized',
            '403': 'Forbidden',
            '404': 'Not Found'
        }

        # print all the codes
        codes = list(status_dict.keys())
        codes.sort()
        for code in codes:
            if code in code_names:
                print(f"  - {code} {code_names[code]}: {status_dict[code]}")
            else:
                print(f"  - {code}: {status_dict[code]}")

    except Exception as e:
        print(f"SOMETHING BROKE!!! Error: {str(e)}")

# Run code with sample data
if __name__ == "__main__":
    print("Running log analyzer with embedded sample data...")
    analyze_log_data(SAMPLE_LOG_DATA)

